<!DOCTYPE html>
<html>

	<head>
		<meta charset="UTF-8">
		<title>动态数据绑定（一）</title>
		<style>
			pre{
				background: #eee;
			}
		</style>
	</head>

	<body>
		<!--<div class="wrap">
			<pre>
//现在有两个对象
let app1 = new Observer({
	name: 'youngwind',
	age: 25
});

let app2 = new Observer({
	university: 'bupt',
	major: 'computer'
});
			</pre>
		</div>
		<label>输入你想要修改或者访问的属性(修改属性时要按照 变量名:key:value的形式传值)</label>
		<input id="value" type="text">
		<button id="submit">提交</button>
		<span id="result"></span>-->
		<script>
			function Observer(obj) {
				this.data = obj;
				this.watch(obj);
			}
			//将对象中的属性和属性值提取出来
			Observer.prototype.watch = function(obj) {
				let val;
				for(let key in obj) {
					//因为因为for...in 循环会把对象原型链上的所有可枚举属性都循环出来，而我们想要的仅仅是这个对象本身拥有的属性，所以要用hasOwnProperty过滤。
					if(obj.hasOwnProperty(key)) {
						val = obj[key];
						this.convert(key, val);
					}
				}
			};
			//增加getter和setter
			Observer.prototype.convert = function(key, val) {
				Object.defineProperty(this.data, key, {
					enumerable: true,
					configurable: true,
					get: function() {
						console.log(`你访问了${key}`);
					},
					set: function(value) {
						let oldKey = key;
						key = value;
						console.log(`你修改了${oldKey}的值为${value}`);
					}
				})
			};
			let app1 = new Observer({
				name: 'youngwind',
				age: 25
			});

			let app2 = new Observer({
				university: 'bupt',
				major: 'computer'
			});
//			document.getElementById("submit").onclick=function(){
//				var value=document.getElementById("value").value,
//				valueArr=value.split(/\:/),
//				len=value.length;
//				if(len===2){
//					
//				}
//			}
		</script>
	</body>

</html>